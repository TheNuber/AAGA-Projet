Projet: AAGA-Projet — Détection de communautés (Girvan–Newman)
Date: 2025-10-17
Branche: main

1) OBJECTIF ET CONTEXTE
   Ce projet implémente l’algorithme de Girvan–Newman (GN) en Java pur (sans framework ni
   librairies runtime externes), calcule la modularité Q d’une partition, fournit une CLI
   pour exécuter l’algorithme sur des fichiers edge-list et génère des sorties avec la
   partition et la modularité obtenues.

2) CE QUI A ÉTÉ RÉALISÉ
   - Réécriture en Java pur (aucune dépendance runtime), uniquement JUnit en scope test.
   - Implémentation d’un graphe simple (non orienté) et des arêtes:
       * SimpleGraph.java: liste d’adjacence, ajout/suppression d’arêtes, voisins, etc.
       * Edge.java: arête non orientée (égalité/hashCode déterministes).
   - Algorithmes:
       * GirvanNewman.java: GN standard. À chaque itération: calcule la centralité
         d’intermédiarité des arêtes (Brandes), supprime la/les arêtes de plus forte
         centralité, et enregistre la partition (composantes connexes).
       * Modularity.java: calcul de la modularité Q pour une partition donnée.
   - Chargement des données:
       * GraphLoader.java: lecture d’un edge-list (2 colonnes par ligne, séparateur regex).
   - CLI en Java pur:
       * Main.java: parse des arguments (-i, -d, -o, -a), exécute GN, exporte les résultats.
       * Création automatique des répertoires de sortie si nécessaire.
   - Données exemple:
       * data/sample.edgelist: dataset synthétique plus grand (2 communautés de 50 nœuds,
         anneaux + chords internes, quelques liens inter-communautés).
   - Tests:
       * ModularityTest.java: test simple (mvn test PASS).
   - Documentation:
       * README.md: instructions de build/run et description brève.
       * DOCUMENTATION.txt: ce document détaillé (algorithmes, métriques, datasets, etc.).

3) STRUCTURE DU CODE
   - pom.xml                         (projet Maven, JUnit en test uniquement)
   - src/main/java/com/thenuber/aaga/
       * Main.java                   (CLI)
       * GraphLoader.java            (chargement edge-list)
       * SimpleGraph.java            (structure de graphe non orienté)
       * Edge.java                   (représentation d’une arête)
       * GirvanNewman.java           (algorithme GN + betweenness de Brandes)
       * Modularity.java             (calcul de la modularité Q)
   - src/test/java/com/thenuber/aaga/
       * ModularityTest.java         (test unitaire de base)
   - data/
       * sample.edgelist             (dataset synthétique plus grand)
   - target/                         (artefacts de build Maven)

4) UTILISATION (Windows, cmd.exe ou PowerShell)
   4.1 Compilation
       mvn -DskipTests package

   4.2 Exécution (exemples)
       java -jar target\aaga-projet-0.1.0-SNAPSHOT.jar -i data\sample.edgelist -o results\run1

   4.3 Options CLI
       -i  chemin du fichier edge-list (obligatoire)
       -d  regex du délimiteur (défaut: \t)
       -o  préfixe de sortie (défaut: out)
       -a  algorithme: gn (défaut)

   4.4 Sorties
       - <prefix>_partition.txt : liste (sommet \t id_communaute)
       - <prefix>_metrics.txt   : "modularity\t<valeur_Q>"

5) DÉTAILS ALGORITHMIQUES
     5.1 Girvan–Newman (GN) standard — principe détaillé
             - Idée: identifier les "ponts" entre communautés en supprimant itérativement les
                 arêtes les plus "centrales" du point de vue des plus courts chemins.
             - Centralité d’intermédiarité d’une arête e:
                     * Nombre de plus courts chemins entre toutes paires (s, t) qui passent par e,
                         normalisé par le nombre total de plus courts chemins entre (s, t).
                     * Intuition: une arête très centrale relie souvent des groupes faiblement connectés.
             - Étapes (schéma):
                     1) Calculer la betweenness (intermédiarité) de toutes les arêtes.
                     2) Supprimer l’arête (ou toutes les arêtes ex-aequo) de betweenness maximale.
                     3) Recalculer les composantes connexes (partition actuelle du graphe) et l’enregistrer.
                     4) Répéter 1–3 jusqu’à suppression de toutes les arêtes (ou jusqu’à un critère d’arrêt).
             - Sortie: une suite de partitions (une par niveau du dendrogramme implicite). On peut
                 ensuite sélectionner la partition qui maximise la modularité (ou selon un autre critère).

             Implémentation de la betweenness (Brandes adaptée aux arêtes)
             - Pour chaque source s:
                     * BFS (graphe non pondéré) pour obtenir:
                             - dist[v]: distance de s à v
                             - sigma[v]: nombre de plus courts chemins de s à v
                             - preds[v]: prédécesseurs de v sur les plus courts chemins
                     * Accumulation (en dépilant la pile d’ordre topologique) pour propager la "dépendance"
                         delta[] et incrémenter la betweenness des arêtes (v, w) sur les chemins de s.
             - Pour un graphe non orienté, on divise par 2 à la fin (chaque chemin est compté 2 fois).

             Complexité (ordre de grandeur, graphe non pondéré)
             - Brandes (betweenness) par source s: O(E) avec BFS + accumulation; total par passe:
                     * O(VE).
             - GN complet: betweenness recalculée après chaque suppression d’arête → coût élevé sur
                 grands graphes; d’où l’intérêt des variantes approximatives/itératives.

   5.2 Modularity Q
             - Mesure la qualité d’une partition en comparant la densité d’arêtes intra-communautés
                 à celle attendue dans un graphe aléatoire de même distribution de degrés (modèle configuration).
             - Formule (notation standard):
                     Q = (1 / (2m)) * Σ_{i,j} [ A_{ij} - (k_i k_j) / (2m) ] * δ(c_i, c_j)
                     où:
                         m     = nombre total d’arêtes,
                         A_{ij}= 1 si arête (i,j) existe, 0 sinon (graphe simple non pondéré),
                         k_i   = degré du sommet i,
                         c_i   = communauté de i,
                         δ     = 1 si c_i = c_j, 0 sinon.
             - Interprétation:
                     * Q ∈ [-1, 1] (souvent [0, 1] en pratique). Plus Q est élevé, mieux la partition
                         capture une structure communautaire (beaucoup d’arêtes internes, peu d’externes).
             - Implémentation actuelle: somme naïve O(n^2) pour la clarté; des optimisations sont possibles
                 (agrégation par communautés, pré-calculs des volumes et degrés).

     5.3 Partition et composantes connexes
             - Après chaque suppression, on calcule les composantes connexes via BFS/DFS.
             - La partition est un mapping sommet → identifiant de communauté (0, 1, 2, ...).

     5.4 Critères de sélection de la "meilleure" partition (pistes)
             - Maximiser Q parmi toutes les partitions rencontrées.
             - Arrêt anticipé lorsque Q diminue durablement.
             - Contraintes de taille (ex: nombre de communautés ou tailles minimales/maximales).

6) JEU DE DONNÉES SYNTHÉTIQUE (data/sample.edgelist)
   - Deux communautés A1..A50 et B1..B50.
   - Connexions internes: anneau + chords (d=2) pour densifier localement.
   - Quelques liens inter-communautés: A10–B10, A20–B20, A30–B30, A40–B40, A50–B50.
   - Format: deux colonnes (séparateur tabulation par défaut), lignes commençant par # ignorées.

7) TESTS ET QUALITÉ
   - mvn test : PASS (JUnit 5, test Modularity).
   - Build Maven : PASS.
   - Lint/typecheck : compilation Java 17 OK.

8) LIMITES ACTUELLES
   - Pas encore d’implémentations de variantes accélérées (sampling, recalcul périodique).
   - Modularity en O(n^2) (peut ralentir si très grand n).
   - Pas d’outil de benchmarking système intégré (temps mesuré implicitement au besoin).

9) AMÉLIORATIONS PRÉVUES
   - Variantes d’accélération:
       * Approximation de betweenness par échantillonnage (k sources aléatoires).
       * Recalcul périodique/incrémental (t itérations avant recomputation complète).
   - Scripts d’expérimentation:
       * Batch/PowerShell: exécuter plusieurs tailles de graphes, différentes variantes,
         produire un tableau récapitulatif (temps, modularité Q).
   - Optimisations:
       * Modularity: calcul groupé par communautés.
       * GN: stratégies de tie-breaking, arrêt basé sur maximisation de Q, etc.

10) GUIDE D’EXTENSION RAPIDE
   - Ajouter une variante:
       * Créer une nouvelle classe (ex: GirvanNewmanApprox.java) avec une méthode run(graph, ...).
       * Étendre Main.java: option -a (ex: "approx") → appeler la variante.
   - Ajouter un format de données:
       * Étendre GraphLoader (détecter séparateur, ignorer entêtes, etc.).
   - Ajouter des tests:
       * Créer des graphes jouets (triangles, chaînes, multi-composantes) et valider Q/partitions.

11) DÉPENDANCES ET ENVIRONNEMENT
   - Java 17 (maven-compiler-plugin <release>17</release>).
   - Maven (jar exécutable, Main-Class: com.thenuber.aaga.Main).
   - Aucune dépendance runtime externe (JUnit uniquement côté test).

12) CONTACT / REMARQUES
   - En cas de problème de dossier de sortie non existant, la CLI le crée automatiquement.
   - Sous PowerShell, enchaîner les commandes sur des lignes séparées (éviter "&&" qui peut
     être interprété différemment). Exemple:
       1) mvn -DskipTests package
       2) java -jar target\aaga-projet-0.1.0-SNAPSHOT.jar -i data\sample.edgelist -o results\run1

13) MÉTRIQUES DE SORTIE (fichiers *_metrics.txt)
    - Clé/valeurs écrites actuellement:
        * modularity\t<valeur>
          → valeur de Q pour la partition finale (après la dernière suppression). Note: on
            peut également reporter Q pour la meilleure partition rencontrée, si on ajoute
            ce suivi au code.

    - Interprétation rapide:
        * modularity ~ 0.3–0.7: structure communautaire souvent marquée (selon le graphe).
        * modularity faible (≈ 0): structure faible/peu de communautés denses.
        * À utiliser en comparaison relative entre partitions/algorithmes/datasets.

    - Extensions possibles (faciles à ajouter si besoin):
        * best_modularity: Q maximum rencontré sur l’itération et index de l’itération.
        * communities: nombre de communautés de la partition reportée.
        * components_sizes: tailles des communautés (ex: liste triée).
        * edges_removed / iterations: diagnostics de convergence.
